import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { internal } from "./_generated/api";

// Query para obtener todos los archivos de un tema
export const getByTopic = query({
  args: { topicId: v.id("topics") },
  handler: async (ctx, args) => {
    const files = await ctx.db
      .query("topicFiles")
      .withIndex("by_topic", (q) => q.eq("topicId", args.topicId))
      .order("desc")
      .collect();

    // Obtener URLs de los archivos
    const filesWithUrls = await Promise.all(
      files.map(async (file) => {
        const url = await ctx.storage.getUrl(file.storageId);
        return {
          ...file,
          url,
        };
      })
    );

    return filesWithUrls;
  },
});

// Query para obtener todos los archivos de una asignatura
export const getBySubject = query({
  args: { subjectId: v.id("subjects") },
  handler: async (ctx, args) => {
    const files = await ctx.db
      .query("topicFiles")
      .withIndex("by_subject", (q) => q.eq("subjectId", args.subjectId))
      .order("desc")
      .collect();

    // Obtener URLs de los archivos
    const filesWithUrls = await Promise.all(
      files.map(async (file) => {
        const url = await ctx.storage.getUrl(file.storageId);
        return {
          ...file,
          url,
        };
      })
    );

    return filesWithUrls;
  },
});

// Query para obtener un archivo por ID
export const getById = query({
  args: { fileId: v.id("topicFiles") },
  handler: async (ctx, args) => {
    const file = await ctx.db.get(args.fileId);
    if (!file) return null;

    const url = await ctx.storage.getUrl(file.storageId);
    return {
      ...file,
      url,
    };
  },
});

// Mutation para generar URL de subida
export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    return await ctx.storage.generateUploadUrl();
  },
});

// Mutation para crear registro de archivo despuÃ©s de subida
export const create = mutation({
  args: {
    topicId: v.id("topics"),
    subjectId: v.id("subjects"),
    teacherId: v.id("users"),
    fileName: v.string(),
    fileType: v.string(),
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    const fileId = await ctx.db.insert("topicFiles", {
      topicId: args.topicId,
      subjectId: args.subjectId,
      teacherId: args.teacherId,
      fileName: args.fileName,
      fileType: args.fileType,
      storageId: args.storageId,
      uploadedAt: Date.now(),
    });

    // Schedule indexing of the file asynchronously
    // Only index supported file types: PDF, Word, TXT
    const supportedTypes = [
      "application/pdf",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/msword",
      "text/plain",
      "text/txt",
    ];

    if (supportedTypes.includes(args.fileType)) {
      // Type assertion needed until types are regenerated by convex dev
      await ctx.scheduler.runAfter(0, (internal as any).fileIndexing.indexFile, {
        fileId,
        topicId: args.topicId,
        fileName: args.fileName,
        fileType: args.fileType,
        storageId: args.storageId,
      });
    }

    return fileId;
  },
});

// Mutation para eliminar un archivo
export const remove = mutation({
  args: { fileId: v.id("topicFiles") },
  handler: async (ctx, args) => {
    const file = await ctx.db.get(args.fileId);
    if (!file) {
      throw new Error("Archivo no encontrado");
    }

    // Eliminar el archivo del storage
    await ctx.storage.delete(file.storageId);
    
    // Eliminar el registro de la base de datos
    await ctx.db.delete(args.fileId);
  },
});

