import { v } from "convex/values";
import { mutation, query, internalMutation } from "./_generated/server";
import { internal } from "./_generated/api";

// Query para obtener todos los archivos de un tema
export const getByTopic = query({
  args: { topicId: v.id("topics") },
  handler: async (ctx, args) => {
    const files = await ctx.db
      .query("topicFiles")
      .withIndex("by_topic", (q) => q.eq("topicId", args.topicId))
      .order("desc")
      .collect();

    // Obtener URLs de los archivos
    const filesWithUrls = await Promise.all(
      files.map(async (file) => {
        const url = await ctx.storage.getUrl(file.storageId);
        return {
          ...file,
          url,
        };
      })
    );

    return filesWithUrls;
  },
});

// Query para obtener todos los archivos de una asignatura
export const getBySubject = query({
  args: { subjectId: v.id("subjects") },
  handler: async (ctx, args) => {
    const files = await ctx.db
      .query("topicFiles")
      .withIndex("by_subject", (q) => q.eq("subjectId", args.subjectId))
      .order("desc")
      .collect();

    // Obtener URLs de los archivos
    const filesWithUrls = await Promise.all(
      files.map(async (file) => {
        const url = await ctx.storage.getUrl(file.storageId);
        return {
          ...file,
          url,
        };
      })
    );

    return filesWithUrls;
  },
});

// Query para obtener un archivo por ID
export const getById = query({
  args: { fileId: v.id("topicFiles") },
  handler: async (ctx, args) => {
    const file = await ctx.db.get(args.fileId);
    if (!file) return null;

    const url = await ctx.storage.getUrl(file.storageId);
    return {
      ...file,
      url,
    };
  },
});

// Mutation para generar URL de subida
export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    return await ctx.storage.generateUploadUrl();
  },
});

// Mutation para crear registro de archivo despuÃ©s de subida
export const create = mutation({
  args: {
    topicId: v.id("topics"),
    subjectId: v.id("subjects"),
    teacherId: v.id("users"),
    fileName: v.string(),
    fileType: v.string(),
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    const fileId = await ctx.db.insert("topicFiles", {
      topicId: args.topicId,
      subjectId: args.subjectId,
      teacherId: args.teacherId,
      fileName: args.fileName,
      fileType: args.fileType,
      storageId: args.storageId,
      uploadedAt: Date.now(),
    });

    // Schedule indexing of the file asynchronously
    // Only index supported file types: PDF, Word, TXT
    const supportedTypes = [
      "application/pdf",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/msword",
      "text/plain",
      "text/txt",
    ];

    if (supportedTypes.includes(args.fileType)) {
      // Type assertion needed until types are regenerated by convex dev
      await ctx.scheduler.runAfter(
        0,
        (internal as any).fileIndexing.indexFile,
        {
          fileId,
          topicId: args.topicId,
          fileName: args.fileName,
          fileType: args.fileType,
          storageId: args.storageId,
        }
      );
    }

    return fileId;
  },
});

// Internal mutation to mark file as indexed
export const markAsIndexed = internalMutation({
  args: {
    fileId: v.id("topicFiles"),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.fileId, {
      indexedAt: Date.now(),
    });
  },
});

// Mutation para eliminar un archivo
export const remove = mutation({
  args: { fileId: v.id("topicFiles") },
  handler: async (ctx, args) => {
    const file = await ctx.db.get(args.fileId);
    if (!file) {
      throw new Error("Archivo no encontrado");
    }

    // Guardar topicId antes de eliminar el archivo para poder eliminar los embeddings
    const topicId = file.topicId;

    // Eliminar el archivo del storage
    await ctx.storage.delete(file.storageId);

    // Eliminar el registro de la base de datos
    await ctx.db.delete(args.fileId);

    // Schedule removal of embeddings from RAG asynchronously
    // Only remove embeddings for supported file types that were indexed
    const supportedTypes = [
      "application/pdf",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/msword",
      "text/plain",
      "text/txt",
    ];

    if (supportedTypes.includes(file.fileType)) {
      // Type assertion needed until types are regenerated by convex dev
      await ctx.scheduler.runAfter(
        0,
        (internal as any).fileIndexing.removeFileEmbeddings,
        {
          fileId: args.fileId,
          topicId,
        }
      );
    }
  },
});
